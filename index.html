<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deep Dive Explorer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700&display=swap');
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            margin: 0;
            padding: 0;
            font-family: 'Exo 2', 'Arial', sans-serif;
            background-color: #04142d;
            color: white;
            overflow: hidden;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: none; /* Hidden initially, shown after title screen */
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            z-index: 10;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        .ui-panel {
            background-color: rgba(0, 20, 40, 0.7);
            border-radius: 10px;
            padding: 12px;
            margin: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(0, 150, 220, 0.3);
        }
        #resources-panel {
            flex: 1;
            max-width: 180px;
        }
        #depth-panel {
            flex: 1;
            text-align: center;
            max-width: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #depth-display, #max-depth-display {
            font-weight: bold;
            color: #29b6f6;
        }
        #oxygen-panel {
            display: flex;
            align-items: center;
            flex: 1;
            max-width: 200px;
        }
        #oxygen-bar {
            width: 100%;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin-left: 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        #oxygen-level {
            height: 100%;
            background-color: #00aaff;
            width: 100%;
            transition: width 0.3s;
            box-shadow: 0 0 8px rgba(0, 170, 255, 0.7);
        }
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 20, 40, 0.7);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 150, 220, 0.3);
            z-index: 15;
            padding: 5px;
            backdrop-filter: blur(4px);
            overflow: hidden;
        }
        #minimap-canvas {
            width: 100%;
            height: 100%;
            border-radius: 5px;
        }
        #shop-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(3, 37, 65, 0.95);
            border: 2px solid #00aaff;
            border-radius: 15px;
            padding: 25px;
            z-index: 20;
            min-width: 350px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            display: none;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }
        .shop-category {
            margin-bottom: 20px;
        }
        .shop-category-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #29b6f6;
            border-bottom: 1px solid rgba(41, 182, 246, 0.3);
            padding-bottom: 5px;
        }
        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 15px;
            background-color: rgba(0, 100, 150, 0.2);
            border-radius: 8px;
            border: 1px solid rgba(0, 150, 220, 0.2);
            transition: all 0.2s ease;
        }
        .shop-item:hover {
            background-color: rgba(0, 120, 180, 0.3);
            transform: translateY(-2px);
        }
        .shop-item-info {
            flex: 1;
        }
        .shop-item-name {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        .shop-item-desc {
            font-size: 0.9em;
            opacity: 0.8;
        }
        .shop-item-cost {
            font-size: 0.9em;
            margin-top: 5px;
            color: #ffcc80;
        }
        button {
            background-color: #0288d1;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }
        button:hover {
            background-color: #0277bd;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        button:disabled {
            background-color: #455a64;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #shop-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 15;
            display: flex;
            align-items: center;
            border-radius: 30px;
            padding: 10px 15px;
        }
        #shop-alert {
            width: 12px;
            height: 12px;
            background-color: #ff5252;
            border-radius: 50%;
            margin-left: 8px;
            display: none;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.7; }
        }
        #close-shop {
            background-color: #455a64;
            margin-top: 15px;
        }
        #message-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 20, 40, 0.8);
            padding: 15px 25px;
            border-radius: 30px;
            z-index: 15;
            text-align: center;
            display: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 150, 220, 0.2);
            backdrop-filter: blur(4px);
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, 20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }
        .resource {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .resource-icon {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
        }
        #controls-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background-color: rgba(0, 20, 40, 0.7);
            padding: 8px 15px;
            border-radius: 30px;
            font-size: 0.8em;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(0, 150, 220, 0.2);
            animation: fadeIn 1s ease;
        }
        #mobile-controls {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 15;
            pointer-events: none;
        }
        .mobile-button {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 120, 180, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }
        #collect-button {
            position: absolute;
            bottom: 50px;
            right: 20px;
            width: 70px;
            height: 70px;
            background-color: rgba(255, 100, 100, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            color: white;
            z-index: 15;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }
        
        /* Title Screen Styles */
        #title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #0a2342, #04142d);
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        #title-container {
            text-align: center;
            padding: 20px;
            max-width: 800px;
            position: relative;
            z-index: 2;
        }
        #game-title {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 0 0 15px rgba(0, 150, 255, 0.8);
            animation: glow 3s infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(0, 150, 255, 0.8); }
            to { text-shadow: 0 0 20px rgba(0, 200, 255, 1); }
        }
        #title-subtitle {
            font-size: 1.5rem;
            margin-bottom: 40px;
            color: #29b6f6;
        }
        #play-button {
            font-size: 1.4rem;
            padding: 15px 40px;
            background-color: #0288d1;
            margin-top: 20px;
            border-radius: 30px;
        }
        #bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .bubble {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
            animation: float linear infinite;
            bottom: -50px;
        }
        @keyframes float {
            0% { transform: translateY(0) rotate(0); }
            100% { transform: translateY(-100vh) rotate(360deg); }
        }
        
        /* Customization Panel */
        #customization-panel {
            background-color: rgba(0, 20, 40, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            max-width: 400px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(0, 150, 255, 0.3);
        }
        #customization-title {
            font-size: 1.2rem;
            color: #29b6f6;
            margin-bottom: 15px;
            text-align: center;
        }
        .color-option {
            display: inline-block;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin: 5px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s ease;
        }
        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        .option-row {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        #diver-preview {
            width: 100px;
            height: 100px;
            margin: 15px auto;
            position: relative;
        }
        .preview-circle {
            position: absolute;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #resume-game-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 31;
            padding: 10px 15px;
            font-size: 1rem;
            display: none;
        }
        
        @media (max-width: 768px) {
            #ui-container {
                flex-direction: column;
                align-items: flex-start;
                padding: 10px;
            }
            .ui-panel {
                margin: 3px;
                padding: 8px;
                max-width: none !important;
                width: 100%;
            }
            #controls-info {
                font-size: 0.7em;
            }
            #shop-container {
                max-width: 95%;
                padding: 15px;
            }
            #minimap-container {
                width: 100px;
                height: 100px;
                bottom: 15px;
                right: 15px;
            }
            .mobile-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            #collect-button {
                width: 60px;
                height: 60px;
                font-size: 14px;
            }
            #game-title {
                font-size: 2.5rem;
            }
            #title-subtitle {
                font-size: 1.2rem;
            }
            #customization-panel {
                max-width: 90%;
                padding: 15px;
            }
            .color-option {
                width: 30px;
                height: 30px;
                margin: 3px;
            }
        }
    </style>
</head>
<body>
    <div id="title-screen">
        <div id="bubbles"></div>
        
        <div id="title-container">
            <h1 id="game-title">DEEP DIVE</h1>
            <h2 id="title-subtitle">Explore the depths of the ocean</h2>
            
            <div id="customization-panel">
                <div id="customization-title">Customize Your Diver</div>
                
                <div class="option-row">
                    <div class="color-option selected" style="background-color: #ff9900;" data-color="#ff9900"></div>
                    <div class="color-option" style="background-color: #ff5252;" data-color="#ff5252"></div>
                    <div class="color-option" style="background-color: #4caf50;" data-color="#4caf50"></div>
                    <div class="color-option" style="background-color: #9c27b0;" data-color="#9c27b0"></div>
                    <div class="color-option" style="background-color: #ffeb3b;" data-color="#ffeb3b"></div>
                </div>
                
                <div id="diver-preview">
                    <div class="preview-circle" style="width: 80px; height: 80px; background-color: #ff9900;"></div>
                    <div class="preview-circle" style="width: 30px; height: 15px; background-color: #333; top: 40%; border-radius: 15px 15px 0 0;"></div>
                    <div class="preview-circle" style="width: 15px; height: 30px; background-color: #555; top: 30%; left: 60%;"></div>
                </div>
            </div>
            
            <button id="play-button">DIVE IN</button>
        </div>
    </div>
    
    <button id="resume-game-button">Resume Game</button>
    
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div id="ui-container">
            <div id="resources-panel" class="ui-panel">
                <div style="margin-bottom: 5px; font-weight: bold;">Resources:</div>
                <div id="resources-display"></div>
            </div>
            <div id="depth-panel" class="ui-panel">
                <div>Depth: <span id="depth-display">0</span>m</div>
                <div>Max Depth: <span id="max-depth-display">0</span>m</div>
            </div>
            <div id="oxygen-panel" class="ui-panel">
                <div>O₂:</div>
                <div id="oxygen-bar">
                    <div id="oxygen-level"></div>
                </div>
            </div>
        </div>
        
        <button id="shop-button">Shop <div id="shop-alert"></div></button>
        
        <div id="minimap-container">
            <canvas id="minimap-canvas"></canvas>
        </div>
        
        <div id="shop-container">
            <h2 style="text-align: center; color: #29b6f6; margin-top: 0;">Diving Shop</h2>
            <div id="shop-items"></div>
            <button id="close-shop">Close</button>
        </div>
        
        <div id="message-box"></div>
        
        <div id="controls-info">
            Controls: Arrow keys to move | Space to collect resources
        </div>
        
        <div id="mobile-controls" style="display: none;">
            <div class="mobile-button" id="left-button">←</div>
            <div style="display: flex; flex-direction: column; align-items: center;">
                <div class="mobile-button" id="up-button">↑</div>
                <div class="mobile-button" id="down-button" style="margin-top: 10px;">↓</div>
            </div>
            <div class="mobile-button" id="right-button">→</div>
        </div>
        
        <div id="collect-button" style="display: none;">
            COLLECT
        </div>
    </div>

    <script>
        // Game State
        const gameState = {
            diver: {
                x: 0,
                y: 0,
                width: 30,
                height: 50,
                speed: 3,
                oxygenCapacity: 100,
                oxygenLevel: 100,
                oxygenDepletionRate: 0.2,
                oxygenReplenishRate: 0.1, // Half the depletion rate
                collectRange: 40,
                color: "#ff9900" // Default color
            },
            resources: {
                seaweed: 0,
                coral: 0,
                pearl: 0,
                crystal: 0,
                treasure: 0
            },
            currentDepth: 0,
            reachedMaxDepth: 0,
            previousDepth: 0,
            camera: {
                x: 0,
                y: 0
            },
            levelObjects: [],
            keys: {
                up: false,
                down: false,
                left: false,
                right: false,
                space: false
            },
            respawnTimers: {
                resources: {},
                oxygen: {}
            },
            shopOpen: false,
            gameWidth: 2000,
            gameHeight: 5000,
            backgroundColor: '#04142d',
            lastTimestamp: 0,
            deltaTime: 0,
            paused: false,
            isMobile: false,
            exploredMap: {},
            hasAvailableUpgrades: false,
            gameStarted: false
        };

        // Resource Definitions
        const resourceTypes = {
            seaweed: { name: "Seaweed", minDepth: 0, maxDepth: 300, value: 1, color: "#3cb371", size: 20, respawnTime: 60000 },
            coral: { name: "Coral", minDepth: 50, maxDepth: 500, value: 3, color: "#ff7f50", size: 25, respawnTime: 90000 },
            pearl: { name: "Pearl", minDepth: 150, maxDepth: 800, value: 7, color: "#f0f8ff", size: 15, respawnTime: 120000 },
            crystal: { name: "Crystal", minDepth: 400, maxDepth: 1500, value: 15, color: "#9370db", size: 20, respawnTime: 180000 },
            treasure: { name: "Treasure", minDepth: 800, maxDepth: 3000, value: 50, color: "#ffd700", size: 30, respawnTime: 300000 }
        };

        // Oxygen tank definition for collectibles
        const oxygenTank = {
            name: "Oxygen",
            color: "#00aaff",
            size: 15,
            value: 25, // Amount of oxygen to replenish
            respawnTime: 30000 // 30 seconds
        };

        // Upgrade Definitions - Organized by categories
        const upgrades = [
            // Oxygen category
            { id: "oxygen1", category: "oxygen", name: "Oxygen Tank I", description: "Increase oxygen capacity by 50", cost: { seaweed: 10 }, effect: () => { gameState.diver.oxygenCapacity += 50; } },
            { id: "oxygen2", category: "oxygen", name: "Oxygen Tank II", description: "Increase oxygen capacity by 100", cost: { seaweed: 20, coral: 5 }, effect: () => { gameState.diver.oxygenCapacity += 100; }, requires: ["oxygen1"] },
            { id: "oxygen3", category: "oxygen", name: "Oxygen Tank III", description: "Increase oxygen capacity by 200", cost: { coral: 15, pearl: 5 }, effect: () => { gameState.diver.oxygenCapacity += 200; }, requires: ["oxygen2"] },
            { id: "efficiency1", category: "oxygen", name: "Breathing Regulator", description: "Reduce oxygen consumption by 20%", cost: { coral: 12, pearl: 4 }, effect: () => { gameState.diver.oxygenDepletionRate *= 0.8; } },
            { id: "efficiency2", category: "oxygen", name: "Advanced Regulator", description: "Reduce oxygen consumption by another 20%", cost: { crystal: 6, treasure: 1 }, effect: () => { gameState.diver.oxygenDepletionRate *= 0.8; }, requires: ["efficiency1"] },
            
            // Movement category
            { id: "speed1", category: "movement", name: "Fins I", description: "Increase swimming speed", cost: { seaweed: 15 }, effect: () => { gameState.diver.speed += 1; } },
            { id: "speed2", category: "movement", name: "Fins II", description: "Further increase swimming speed", cost: { coral: 10, pearl: 3 }, effect: () => { gameState.diver.speed += 1.5; }, requires: ["speed1"] },
            { id: "speed3", category: "movement", name: "Propulsion Aid", description: "Significant speed boost", cost: { pearl: 10, crystal: 2 }, effect: () => { gameState.diver.speed += 2; }, requires: ["speed2"] },
            
            // Collection category
            { id: "collector1", category: "collection", name: "Collection Net", description: "Increase collection range", cost: { seaweed: 20, coral: 5 }, effect: () => { gameState.diver.collectRange += 20; } },
            { id: "collector2", category: "collection", name: "Magnetic Collector", description: "Further increase collection range", cost: { pearl: 8, crystal: 3 }, effect: () => { gameState.diver.collectRange += 40; }, requires: ["collector1"] }
        ];

        // Track purchased upgrades
        let purchasedUpgrades = [];

        // Canvas setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Minimap setup
        const minimapCanvas = document.getElementById('minimap-canvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        // UI elements
        const resourcesDisplay = document.getElementById('resources-display');
        const depthDisplay = document.getElementById('depth-display');
        const maxDepthDisplay = document.getElementById('max-depth-display');
        const oxygenLevel = document.getElementById('oxygen-level');
        const shopButton = document.getElementById('shop-button');
        const shopAlert = document.getElementById('shop-alert');
        const shopContainer = document.getElementById('shop-container');
        const shopItems = document.getElementById('shop-items');
        const closeShopButton = document.getElementById('close-shop');
        const messageBox = document.getElementById('message-box');
        const controlsInfo = document.getElementById('controls-info');
        const mobileControls = document.getElementById('mobile-controls');
        const collectButton = document.getElementById('collect-button');
        
        // Title screen elements
        const titleScreen = document.getElementById('title-screen');
        const playButton = document.getElementById('play-button');
        const customizationPanel = document.getElementById('customization-panel');
        const colorOptions = document.querySelectorAll('.color-option');
        const diverPreview = document.querySelector('.preview-circle');
        const gameContainer = document.getElementById('game-container');
        const resumeGameButton = document.getElementById('resume-game-button');
        const bubblesContainer = document.getElementById('bubbles');

        // Initialize game
        function initGame() {
            // Create bubbles for title screen
            createBubbles();
            
            // Check if mobile device
            checkIfMobile();
            
            // Setup title screen interaction
            setupTitleScreen();
            
            // Try to load saved game
            loadGame();
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Generate initial level
            generateLevel();
            
            // Setup event listeners
            setupEventListeners();
            
            // Mark the starting position as explored
            updateExploredMap(gameState.diver.x, gameState.diver.y);
            
            // Initialize minimap
            updateMinimap();
            
            // Check for available upgrades
            checkAvailableUpgrades();
        }
        
        function setupTitleScreen() {
            // Handle color selection
            colorOptions.forEach(option => {
                option.addEventListener('click', () => {
                    // Remove selection from all options
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    
                    // Add selection to clicked option
                    option.classList.add('selected');
                    
                    // Update diver preview
                    const color = option.getAttribute('data-color');
                    diverPreview.style.backgroundColor = color;
                    
                    // Update game state
                    gameState.diver.color = color;
                });
            });
            
            // Handle play button
            playButton.addEventListener('click', startGame);
            
            // Resume game button
            resumeGameButton.addEventListener('click', () => {
                titleScreen.style.display = 'none';
                gameContainer.style.display = 'block';
                gameState.paused = false;
                
                // Hide resume button after use
                resumeGameButton.style.display = 'none';
            });
        }
        
        function createBubbles() {
            // Create bubbles for the animation
            for (let i = 0; i < 20; i++) {
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                
                // Random size between 10px and 50px
                const size = 10 + Math.random() * 40;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                
                // Random horizontal position
                bubble.style.left = `${Math.random() * 100}%`;
                
                // Random delay and duration
                const delay = Math.random() * 15;
                const duration = 7 + Math.random() * 10;
                bubble.style.animation = `float ${duration}s linear ${delay}s infinite`;
                
                // Add to container
                bubblesContainer.appendChild(bubble);
            }
        }
        
        function startGame() {
            // Hide title screen and show game
            titleScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            
            // Initialize diver position
            gameState.diver.x = canvas.width / 2;
            gameState.diver.y = 50;
            
            // Set game as started
            gameState.gameStarted = true;
            
            // Start game loop if not already running
            if (!gameState.lastTimestamp) {
                requestAnimationFrame(gameLoop);
            }
            
            // Periodically save game
            setInterval(saveGame, 30000); // Save every 30 seconds
        }

        function checkIfMobile() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 800;
            
            gameState.isMobile = isMobile;
            
            if (isMobile) {
                mobileControls.style.display = 'flex';
                collectButton.style.display = 'flex';
                controlsInfo.textContent = 'Tap buttons to move and collect';
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            minimapCanvas.width = minimapCanvas.parentElement.clientWidth;
            minimapCanvas.height = minimapCanvas.parentElement.clientHeight;
            
            // Update minimap after resize
            updateMinimap();
        }

        function generateLevel() {
            // Clear existing objects
            gameState.levelObjects = [];
            
            // Generate resources based on depth availability
            const resourceCount = 300; // Total number of resources to generate
            
            for (let i = 0; i < resourceCount; i++) {
                // Determine which resource to place
                const resourceKeys = Object.keys(resourceTypes);
                let resourceTypeKey = resourceKeys[Math.floor(Math.random() * resourceKeys.length)];
                const resourceType = resourceTypes[resourceTypeKey];
                
                // Place resource at appropriate depth
                const x = Math.random() * gameState.gameWidth;
                const y = resourceType.minDepth + Math.random() * (resourceType.maxDepth - resourceType.minDepth);
                
                // Add some randomization to distribution
                if (Math.random() > 0.7) {
                    // Add to level objects
                    gameState.levelObjects.push({
                        type: 'resource',
                        resourceType: resourceTypeKey,
                        x,
                        y,
                        width: resourceType.size,
                        height: resourceType.size,
                        collected: false,
                        id: `resource_${resourceTypeKey}_${i}_${Date.now()}`
                    });
                }
            }
            
            // Generate oxygen tanks
            const oxygenCount = 30;
            for (let i = 0; i < oxygenCount; i++) {
                // Place oxygen tanks at various depths
                const x = Math.random() * gameState.gameWidth;
                const y = 100 + Math.random() * 2000; // Distribute oxygen up to 2000m
                
                gameState.levelObjects.push({
                    type: 'oxygen',
                    x,
                    y,
                    width: oxygenTank.size,
                    height: oxygenTank.size,
                    collected: false,
                    id: `oxygen_${i}_${Date.now()}`
                });
            }
            
            // Add some decorative elements (rocks, plants, etc)
            const decorCount = 200;
            for (let i = 0; i < decorCount; i++) {
                const x = Math.random() * gameState.gameWidth;
                const y = Math.random() * gameState.gameHeight;
                const size = 10 + Math.random() * 30;
                
                gameState.levelObjects.push({
                    type: 'decor',
                    x,
                    y,
                    width: size,
                    height: size,
                    color: `rgba(${100 + Math.random() * 155}, ${100 + Math.random() * 155}, ${100 + Math.random() * 155}, ${0.2 + Math.random() * 0.3})`
                });
            }
        }

        function setupEventListeners() {
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                updateKeys(e.key, true);
            });
            
            window.addEventListener('keyup', (e) => {
                updateKeys(e.key, false);
            });
            
            // Shop controls
            shopButton.addEventListener('click', toggleShop);
            closeShopButton.addEventListener('click', toggleShop);
            
            // Mobile controls
            if (gameState.isMobile) {
                setupMobileControls();
            }
            
            // ESC key to show title screen
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && gameState.gameStarted) {
                    showTitleScreen();
                }
            });
        }
        
        function showTitleScreen() {
            if (!gameState.shopOpen) {
                titleScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
                gameState.paused = true;
                resumeGameButton.style.display = 'block';
            }
        }
        
        function setupMobileControls() {
            // Direction buttons
            const upButton = document.getElementById('up-button');
            const downButton = document.getElementById('down-button');
            const leftButton = document.getElementById('left-button');
            const rightButton = document.getElementById('right-button');
            
            // Touch events for direction buttons
            upButton.addEventListener('touchstart', () => { gameState.keys.up = true; });
            upButton.addEventListener('touchend', () => { gameState.keys.up = false; });
            
            downButton.addEventListener('touchstart', () => { gameState.keys.down = true; });
            downButton.addEventListener('touchend', () => { gameState.keys.down = false; });
            
            leftButton.addEventListener('touchstart', () => { gameState.keys.left = true; });
            leftButton.addEventListener('touchend', () => { gameState.keys.left = false; });
            
            rightButton.addEventListener('touchstart', () => { gameState.keys.right = true; });
            rightButton.addEventListener('touchend', () => { gameState.keys.right = false; });
            
            // Collect button
            const collectBtn = document.getElementById('collect-button');
            collectBtn.addEventListener('touchstart', () => { gameState.keys.space = true; });
            collectBtn.addEventListener('touchend', () => { gameState.keys.space = false; });
            
            // Prevent default touch behavior to avoid scrolling
            document.addEventListener('touchmove', (e) => {
                if (e.target === canvas || 
                    e.target.className === 'mobile-button' || 
                    e.target.id === 'collect-button') {
                    e.preventDefault();
                }
            }, { passive: false });
        }

        function updateKeys(key, isPressed) {
            switch (key) {
                case 'ArrowUp':
                case 'w':
                    gameState.keys.up = isPressed;
                    break;
                case 'ArrowDown':
                case 's':
                    gameState.keys.down = isPressed;
                    break;
                case 'ArrowLeft':
                case 'a':
                    gameState.keys.left = isPressed;
                    break;
                case 'ArrowRight':
                case 'd':
                    gameState.keys.right = isPressed;
                    break;
                case ' ':
                    gameState.keys.space = isPressed;
                    break;
                case 'Escape':
                    // Handled separately to avoid conflicts
                    break;
            }
        }

        function toggleShop() {
            gameState.shopOpen = !gameState.shopOpen;
            
            if (gameState.shopOpen) {
                gameState.paused = true;
                shopContainer.style.display = 'block';
                updateShopItems();
            } else {
                gameState.paused = false;
                shopContainer.style.display = 'none';
            }
            
            // Hide alert if shop is opened
            if (gameState.shopOpen) {
                shopAlert.style.display = 'none';
            }
        }

        function updateShopItems() {
            shopItems.innerHTML = '';
            
            // Group upgrades by category
            const categories = {
                oxygen: { title: "Oxygen Equipment", items: [] },
                movement: { title: "Movement Gear", items: [] },
                collection: { title: "Collection Tools", items: [] }
            };
            
            // Filter available upgrades
            upgrades.forEach(upgrade => {
                // Skip if already purchased
                if (purchasedUpgrades.includes(upgrade.id)) return;
                
                // Check if prerequisites are met
                if (upgrade.requires && !upgrade.requires.every(req => purchasedUpgrades.includes(req))) return;
                
                // Add to appropriate category
                categories[upgrade.category].items.push(upgrade);
            });
            
            // Create HTML for each category
            Object.values(categories).forEach(category => {
                if (category.items.length === 0) return;
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'shop-category';
                
                const categoryTitle = document.createElement('div');
                categoryTitle.className = 'shop-category-title';
                categoryTitle.textContent = category.title;
                categoryDiv.appendChild(categoryTitle);
                
                category.items.forEach(upgrade => {
                    const item = document.createElement('div');
                    item.className = 'shop-item';
                    
                    const info = document.createElement('div');
                    info.className = 'shop-item-info';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'shop-item-name';
                    nameDiv.textContent = upgrade.name;
                    
                    const descDiv = document.createElement('div');
                    descDiv.className = 'shop-item-desc';
                    descDiv.textContent = upgrade.description;
                    
                    const costDiv = document.createElement('div');
                    costDiv.className = 'shop-item-cost';
                    costDiv.textContent = `Cost: ${formatCost(upgrade.cost)}`;
                    
                    info.appendChild(nameDiv);
                    info.appendChild(descDiv);
                    info.appendChild(costDiv);
                    
                    const button = document.createElement('button');
                    button.textContent = 'Buy';
                    button.onclick = () => purchaseUpgrade(upgrade);
                    
                    // Check if player can afford it
                    if (!canAfford(upgrade.cost)) {
                        button.disabled = true;
                    }
                    
                    item.appendChild(info);
                    item.appendChild(button);
                    categoryDiv.appendChild(item);
                });
                
                shopItems.appendChild(categoryDiv);
            });
            
            if (shopItems.children.length === 0) {
                shopItems.innerHTML = '<div style="text-align: center; padding: 20px;">No more upgrades available!</div>';
            }
        }

        function formatCost(cost) {
            return Object.entries(cost)
                .map(([resource, amount]) => `${amount} ${resourceTypes[resource].name}`)
                .join(', ');
        }

        function canAfford(cost) {
            return Object.entries(cost).every(([resource, amount]) => 
                gameState.resources[resource] >= amount
            );
        }

        function purchaseUpgrade(upgrade) {
            if (!canAfford(upgrade.cost)) return;
            
            // Deduct resources
            Object.entries(upgrade.cost).forEach(([resource, amount]) => {
                gameState.resources[resource] -= amount;
            });
            
            // Apply upgrade
            upgrade.effect();
            
            // Mark as purchased
            purchasedUpgrades.push(upgrade.id);
            
            // Update displays
            updateResourcesDisplay();
            updateShopItems();
            
            // Check for available upgrades after purchase
            checkAvailableUpgrades();
            
            // Show message
            showMessage(`Upgraded: ${upgrade.name}`);
            
            // Refill oxygen when buying upgrades (quality of life)
            gameState.diver.oxygenLevel = gameState.diver.oxygenCapacity;
            
            // Save game after purchase
            saveGame();
        }

        function showMessage(text, duration = 3000) {
            messageBox.textContent = text;
            messageBox.style.display = 'block';
            
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }
        
        function checkAvailableUpgrades() {
            // Check if there are any upgrades the player can afford
            let hasAvailable = false;
            
            for (const upgrade of upgrades) {
                // Skip if already purchased
                if (purchasedUpgrades.includes(upgrade.id)) continue;
                
                // Skip if prerequisites are not met
                if (upgrade.requires && !upgrade.requires.every(req => purchasedUpgrades.includes(req))) continue;
                
                // Check if player can afford it
                if (canAfford(upgrade.cost)) {
                    hasAvailable = true;
                    break;
                }
            }
            
            // Update game state and UI
            gameState.hasAvailableUpgrades = hasAvailable;
            shopAlert.style.display = hasAvailable ? 'block' : 'none';
        }

        function updateExploredMap(x, y) {
            // Calculate grid cell for the current position (10x10 grid cells)
            const gridX = Math.floor(x / 50);
            const gridY = Math.floor(y / 50);
            
            // Mark as explored
            const key = `${gridX},${gridY}`;
            gameState.exploredMap[key] = true;
            
            // Also mark adjacent cells as partially explored
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue; // Skip the center
                    
                    const adjKey = `${gridX + dx},${gridY + dy}`;
                    if (!gameState.exploredMap[adjKey]) {
                        gameState.exploredMap[adjKey] = 'partial';
                    }
                }
            }
        }

        function updateMinimap() {
            // Clear minimap
            minimapCtx.fillStyle = '#04142d';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Calculate scale factors
            const scaleX = minimapCanvas.width / gameState.gameWidth;
            const scaleY = minimapCanvas.height / gameState.gameHeight;
            
            // Draw explored areas
            for (const key in gameState.exploredMap) {
                const [gridX, gridY] = key.split(',').map(Number);
                const x = gridX * 50 * scaleX;
                const y = gridY * 50 * scaleY;
                const width = 50 * scaleX;
                const height = 50 * scaleY;
                
                // Different colors for fully explored vs partially explored
                if (gameState.exploredMap[key] === true) {
                    minimapCtx.fillStyle = 'rgba(41, 182, 246, 0.5)';
                } else {
                    minimapCtx.fillStyle = 'rgba(41, 182, 246, 0.2)';
                }
                
                minimapCtx.fillRect(x, y, width, height);
            }
            
            // Draw resources on the minimap (small dots)
            gameState.levelObjects.forEach(obj => {
                if ((obj.type === 'resource' || obj.type === 'oxygen') && !obj.collected) {
                    const x = obj.x * scaleX;
                    const y = obj.y * scaleY;
                    
                    if (obj.type === 'resource') {
                        minimapCtx.fillStyle = resourceTypes[obj.resourceType].color;
                    } else {
                        minimapCtx.fillStyle = oxygenTank.color;
                    }
                    
                    minimapCtx.beginPath();
                    minimapCtx.arc(x, y, 1.5, 0, Math.PI * 2);
                    minimapCtx.fill();
                }
            });
            
            // Draw diver position
            const diverX = gameState.diver.x * scaleX;
            const diverY = gameState.diver.y * scaleY;
            
            minimapCtx.fillStyle = gameState.diver.color;
            minimapCtx.beginPath();
            minimapCtx.arc(diverX, diverY, 3, 0, Math.PI * 2);
            minimapCtx.fill();
            
            // Draw a small rectangle showing the current view area
            const viewX = gameState.camera.x * scaleX;
            const viewY = gameState.camera.y * scaleY;
            const viewWidth = canvas.width * scaleX;
            const viewHeight = canvas.height * scaleY;
            
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(viewX, viewY, viewWidth, viewHeight);
        }
        
        // Respawn functions
        function scheduleRespawn(obj) {
            if (obj.type === 'resource') {
                const resourceType = resourceTypes[obj.resourceType];
                const respawnTime = resourceType.respawnTime;
                
                // Schedule respawn
                gameState.respawnTimers.resources[obj.id] = setTimeout(() => {
                    // Find object and mark as uncollected
                    const objIndex = gameState.levelObjects.findIndex(item => item.id === obj.id);
                    if (objIndex !== -1) {
                        gameState.levelObjects[objIndex].collected = false;
                    }
                }, respawnTime);
            }
            else if (obj.type === 'oxygen') {
                // Schedule respawn
                gameState.respawnTimers.oxygen[obj.id] = setTimeout(() => {
                    // Find object and mark as uncollected
                    const objIndex = gameState.levelObjects.findIndex(item => item.id === obj.id);
                    if (objIndex !== -1) {
                        gameState.levelObjects[objIndex].collected = false;
                    }
                }, oxygenTank.respawnTime);
            }
        }
        
        // Local Storage Functions
        function saveGame() {
            if (!gameState.gameStarted) return;
            
            const saveData = {
                diver: {
                    oxygenCapacity: gameState.diver.oxygenCapacity,
                    oxygenDepletionRate: gameState.diver.oxygenDepletionRate,
                    speed: gameState.diver.speed,
                    collectRange: gameState.diver.collectRange,
                    color: gameState.diver.color
                },
                resources: gameState.resources,
                reachedMaxDepth: gameState.reachedMaxDepth,
                purchasedUpgrades: purchasedUpgrades,
                exploredMap: gameState.exploredMap
            };
            
            try {
                localStorage.setItem('deepDiveSave', JSON.stringify(saveData));
                console.log('Game saved successfully');
            } catch (error) {
                console.error('Failed to save game:', error);
            }
        }
        
        function loadGame() {
            try {
                const saveData = localStorage.getItem('deepDiveSave');
                
                if (saveData) {
                    const parsedData = JSON.parse(saveData);
                    
                    // Load diver stats
                    gameState.diver.oxygenCapacity = parsedData.diver.oxygenCapacity || 100;
                    gameState.diver.oxygenDepletionRate = parsedData.diver.oxygenDepletionRate || 0.2;
                    gameState.diver.speed = parsedData.diver.speed || 3;
                    gameState.diver.collectRange = parsedData.diver.collectRange || 40;
                    
                    if (parsedData.diver.color) {
                        gameState.diver.color = parsedData.diver.color;
                        
                        // Update color selection in the UI
                        colorOptions.forEach(option => {
                            if (option.getAttribute('data-color') === parsedData.diver.color) {
                                colorOptions.forEach(opt => opt.classList.remove('selected'));
                                option.classList.add('selected');
                                diverPreview.style.backgroundColor = parsedData.diver.color;
                            }
                        });
                    }
                    
                    // Load resources
                    if (parsedData.resources) {
                        gameState.resources = parsedData.resources;
                    }
                    
                    // Load max depth
                    if (parsedData.reachedMaxDepth) {
                        gameState.reachedMaxDepth = parsedData.reachedMaxDepth;
                    }
                    
                    // Load purchased upgrades
                    if (parsedData.purchasedUpgrades) {
                        purchasedUpgrades = parsedData.purchasedUpgrades;
                    }
                    
                    // Load explored map
                    if (parsedData.exploredMap) {
                        gameState.exploredMap = parsedData.exploredMap;
                    }
                    
                    // Show resume button
                    resumeGameButton.style.display = 'block';
                    
                    console.log('Game loaded successfully');
                    
                    // Set game as started to enable saving
                    gameState.gameStarted = true;
                    
                    return true;
                }
            } catch (error) {
                console.error('Failed to load game:', error);
            }
            
            return false;
        }
        
        function resetGame() {
            localStorage.removeItem('deepDiveSave');
            location.reload();
        }

        function gameLoop(timestamp) {
            // Calculate delta time for smooth movement
            if (!gameState.lastTimestamp) gameState.lastTimestamp = timestamp;
            gameState.deltaTime = (timestamp - gameState.lastTimestamp) / 1000; // in seconds
            gameState.lastTimestamp = timestamp;
            
            if (!gameState.paused) {
                update();
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }

        function update() {
            // Store previous depth for comparison
            gameState.previousDepth = gameState.currentDepth;
            
            // Update diver position based on keys
            if (gameState.keys.up) gameState.diver.y -= gameState.diver.speed * 60 * gameState.deltaTime;
            if (gameState.keys.down) gameState.diver.y += gameState.diver.speed * 60 * gameState.deltaTime;
            if (gameState.keys.left) gameState.diver.x -= gameState.diver.speed * 60 * gameState.deltaTime;
            if (gameState.keys.right) gameState.diver.x += gameState.diver.speed * 60 * gameState.deltaTime;
            
            // Constrain diver to game bounds
            gameState.diver.x = Math.max(0, Math.min(gameState.gameWidth, gameState.diver.x));
            
            // Allow diving to any depth, just constrain to game bounds
            gameState.diver.y = Math.max(50, Math.min(gameState.gameHeight, gameState.diver.y));
            
            // Update current depth and max reached
            gameState.currentDepth = Math.floor(gameState.diver.y);
            gameState.reachedMaxDepth = Math.max(gameState.reachedMaxDepth, gameState.currentDepth);
            
            // Update camera to follow diver
            gameState.camera.x = gameState.diver.x - canvas.width / 2;
            gameState.camera.y = gameState.diver.y - canvas.height / 2;
            
            // Keep camera within game bounds
            gameState.camera.x = Math.max(0, Math.min(gameState.gameWidth - canvas.width, gameState.camera.x));
            gameState.camera.y = Math.max(0, Math.min(gameState.gameHeight - canvas.height, gameState.camera.y));
            
            // Update explored map
            updateExploredMap(gameState.diver.x, gameState.diver.y);
            
            // Update minimap (not every frame for performance)
            if (Math.random() < 0.05) {
                updateMinimap();
            }
            
            // Check if the diver is ascending or descending
            const isAscending = gameState.currentDepth < gameState.previousDepth;
            
            // Update oxygen level based on direction
            if (isAscending && gameState.currentDepth < 300) {
                // Replenish oxygen when ascending in shallow waters
                gameState.diver.oxygenLevel += gameState.diver.oxygenReplenishRate * gameState.deltaTime * 60;
            } else {
                // Deplete oxygen faster at deeper depths
                const depthFactor = 1 + (gameState.currentDepth / 500); // Less severe depth penalty
                gameState.diver.oxygenLevel -= gameState.diver.oxygenDepletionRate * depthFactor * gameState.deltaTime * 60;
            }
            
            // Clamp oxygen level
            gameState.diver.oxygenLevel = Math.max(0, Math.min(gameState.diver.oxygenCapacity, gameState.diver.oxygenLevel));
            
            // If oxygen is too low, warn the player
            if (gameState.diver.oxygenLevel < gameState.diver.oxygenCapacity * 0.2 && Math.random() < 0.01) {
                showMessage("Warning: Oxygen level critical!");
            }
            
            // If oxygen is depleted, return to surface
            if (gameState.diver.oxygenLevel <= 0) {
                gameState.diver.y = 50; // Return to surface
                gameState.diver.oxygenLevel = gameState.diver.oxygenCapacity; // Refill oxygen
                showMessage("You ran out of oxygen and had to surface!");
            }
            
            // Refill oxygen when near surface
            if (gameState.diver.y < 60) {
                gameState.diver.oxygenLevel += gameState.diver.oxygenCapacity * 0.02 * gameState.deltaTime * 60;
                if (gameState.diver.oxygenLevel > gameState.diver.oxygenCapacity) {
                    gameState.diver.oxygenLevel = gameState.diver.oxygenCapacity;
                }
            }
            
            // Collect resources
            if (gameState.keys.space) {
                collectResources();
            }
            
            // Check for available upgrades periodically
            if (Math.random() < 0.02) {
                checkAvailableUpgrades();
            }
            
            // Update UI displays
            updateUI();
        }

        function collectResources() {
            gameState.levelObjects.forEach(obj => {
                if ((obj.type === 'resource' || obj.type === 'oxygen') && !obj.collected) {
                    // Check if diver is in range of the resource
                    const dx = obj.x - gameState.diver.x;
                    const dy = obj.y - gameState.diver.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= gameState.diver.collectRange) {
                        // Collect the resource
                        obj.collected = true;
                        
                        // Schedule respawn
                        scheduleRespawn(obj);
                        
                        if (obj.type === 'resource') {
                            // Add to player's resources
                            gameState.resources[obj.resourceType]++;
                            
                            // Show collection message
                            const resourceName = resourceTypes[obj.resourceType].name;
                            showMessage(`Collected: ${resourceName}`);
                        } else if (obj.type === 'oxygen') {
                            // Replenish oxygen
                            gameState.diver.oxygenLevel += oxygenTank.value;
                            if (gameState.diver.oxygenLevel > gameState.diver.oxygenCapacity) {
                                gameState.diver.oxygenLevel = gameState.diver.oxygenCapacity;
                            }
                            
                            // Show collection message
                            showMessage(`Collected: Oxygen +${oxygenTank.value}`);
                        }
                        
                        // Check if new upgrades are available after collection
                        checkAvailableUpgrades();
                    }
                }
            });
        }

        function updateUI() {
            // Update depth display
            depthDisplay.textContent = gameState.currentDepth;
            maxDepthDisplay.textContent = gameState.reachedMaxDepth;
            
            // Update oxygen level
            const oxygenPercent = (gameState.diver.oxygenLevel / gameState.diver.oxygenCapacity) * 100;
            oxygenLevel.style.width = `${oxygenPercent}%`;
            
            // Change oxygen color based on level
            if (oxygenPercent > 60) {
                oxygenLevel.style.backgroundColor = "#00aaff";
                oxygenLevel.style.boxShadow = "0 0 8px rgba(0, 170, 255, 0.7)";
            } else if (oxygenPercent > 30) {
                oxygenLevel.style.backgroundColor = "#ffaa00";
                oxygenLevel.style.boxShadow = "0 0 8px rgba(255, 170, 0, 0.7)";
            } else {
                oxygenLevel.style.backgroundColor = "#ff3300";
                oxygenLevel.style.boxShadow = "0 0 8px rgba(255, 51, 0, 0.7)";
            }
            
            // Update resources display
            updateResourcesDisplay();
        }

        function updateResourcesDisplay() {
            resourcesDisplay.innerHTML = '';
            
            Object.entries(gameState.resources).forEach(([resource, amount]) => {
                if (amount > 0) {
                    const resourceElement = document.createElement('div');
                    resourceElement.className = 'resource';
                    
                    const resourceIcon = document.createElement('div');
                    resourceIcon.className = 'resource-icon';
                    resourceIcon.style.backgroundColor = resourceTypes[resource].color;
                    
                    const resourceText = document.createElement('div');
                    resourceText.textContent = `${resourceTypes[resource].name}: ${amount}`;
                    
                    resourceElement.appendChild(resourceIcon);
                    resourceElement.appendChild(resourceText);
                    resourcesDisplay.appendChild(resourceElement);
                }
            });
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = gameState.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply depth-based gradient overlay
            renderBackgroundGradient();
            
            // Render game objects (apply camera offset)
            renderGameObjects();
            
            // Render diver
            renderDiver();
            
            // Render depth lines
            renderDepthLines();
            
            // Render vignette effect at deeper depths
            renderDepthEffect();
        }

        function renderBackgroundGradient() {
            // Create a depth-based gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0077be'); // Lighter blue at top
            gradient.addColorStop(0.3, '#005a87'); // Medium blue
            gradient.addColorStop(1, '#003151'); // Dark blue at bottom
            
            // Apply gradient with transparency
            ctx.globalAlpha = 0.3 + Math.min(0.7, gameState.currentDepth / 1500);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;
        }

        function renderGameObjects() {
            gameState.levelObjects.forEach(obj => {
                // Skip if out of view
                if (isOutOfView(obj)) return;
                
                // Skip if already collected
                if ((obj.type === 'resource' || obj.type === 'oxygen') && obj.collected) return;
                
                // Calculate screen position
                const screenX = obj.x - gameState.camera.x;
                const screenY = obj.y - gameState.camera.y;
                
                if (obj.type === 'resource') {
                    // Render resource
                    const resourceType = resourceTypes[obj.resourceType];
                    ctx.fillStyle = resourceType.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, resourceType.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add shine effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    ctx.arc(screenX - resourceType.size / 4, screenY - resourceType.size / 4, resourceType.size / 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add pulsing effect
                    const pulseSize = Math.sin(Date.now() / 500) * 3;
                    ctx.strokeStyle = resourceType.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, (resourceType.size / 2) + pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (obj.type === 'oxygen') {
                    // Render oxygen tank
                    ctx.fillStyle = oxygenTank.color;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, oxygenTank.size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add oxygen symbol
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('O₂', screenX, screenY);
                    
                    // Add glow effect
                    const pulseSize = Math.sin(Date.now() / 300) * 3;
                    ctx.strokeStyle = 'rgba(0, 170, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, (oxygenTank.size / 2) + pulseSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                } else if (obj.type === 'decor') {
                    // Render decorative element
                    ctx.fillStyle = obj.color;
                    ctx.fillRect(screenX, screenY, obj.width, obj.height);
                }
            });
        }

        function isOutOfView(obj) {
            return (obj.x + obj.width < gameState.camera.x ||
                    obj.x - obj.width > gameState.camera.x + canvas.width ||
                    obj.y + obj.height < gameState.camera.y ||
                    obj.y - obj.height > gameState.camera.y + canvas.height);
        }

        function renderDiver() {
            const screenX = gameState.diver.x - gameState.camera.x;
            const screenY = gameState.diver.y - gameState.camera.y;
            
            // Draw diver body
            ctx.fillStyle = gameState.diver.color;
            ctx.beginPath();
            ctx.arc(screenX, screenY, gameState.diver.width / 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Add a glow effect
            const gradient = ctx.createRadialGradient(
                screenX, screenY, gameState.diver.width / 2,
                screenX, screenY, gameState.diver.width
            );
            gradient.addColorStop(0, `rgba(${hexToRgb(gameState.diver.color)}, 0.3)`);
            gradient.addColorStop(1, `rgba(${hexToRgb(gameState.diver.color)}, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, gameState.diver.width, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw diving mask
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(screenX, screenY - 5, gameState.diver.width / 4, 0, Math.PI);
            ctx.fill();
            
            // Draw oxygen tank
            ctx.fillStyle = '#555';
            ctx.fillRect(screenX - 5, screenY - 15, 10, 20);
            
            // Draw collection range indicator (faintly)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(screenX, screenY, gameState.diver.collectRange, 0, Math.PI * 2);
            ctx.stroke();
            
            // Add a small dotted line for visibility
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(screenX, screenY, gameState.diver.collectRange, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Bubbles effect
            if (Math.random() < 0.1) {
                gameState.levelObjects.push({
                    type: 'decor',
                    x: gameState.diver.x,
                    y: gameState.diver.y - 10,
                    width: 3 + Math.random() * 5,
                    height: 3 + Math.random() * 5,
                    color: 'rgba(255, 255, 255, 0.5)'
                });
            }
        }

        function renderDepthLines() {
            // Render depth markers every 100m
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            const startDepth = Math.floor(gameState.camera.y / 100) * 100;
            
            for (let depth = startDepth; depth <= startDepth + canvas.height + 100; depth += 100) {
                if (depth < 0) continue;
                
                const y = depth - gameState.camera.y;
                
                // Only draw if in view
                if (y >= 0 && y <= canvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    
                    // Label the depth
                    ctx.fillText(`${depth}m`, 10, y - 5);
                }
            }
        }

        function renderDepthEffect() {
            // Add vignette effect that increases with depth
            const depthFactor = Math.min(0.7, (gameState.currentDepth / 2000) * 0.7);
            
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.height / 10,
                canvas.width / 2, canvas.height / 2, canvas.height
            );
            
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, `rgba(0, 0, 30, ${depthFactor})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add pressure/depth effect with blue tint
            ctx.fillStyle = `rgba(0, 20, 40, ${depthFactor * 0.3})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Utility function to convert hex to rgb for glow effect
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Parse the components
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return `${r}, ${g}, ${b}`;
        }

        // Start the game when loaded
        window.onload = initGame;
    </script>
</body>
</html>